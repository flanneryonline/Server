#!/usr/bin/env bash

#main entry point for install
clean_install(){
    echo "starting zfs boot setup"
    zfs_boot_setup
    errorcheck && echoerr "error setting up boot disks." && return 1

    echo "starting debootstrap"
    debootstrap --components $SERVER_DIST_COMPONENTS \
        --include $SERVER_DIST_PACKAGES \
        $SERVER_DIST_RELEASE "$root" $SERVER_DIST_URL
    errorcheck && echoerr "error in debootstrap" && return 1

    echo "bind mounting install location"
    mount --rbind /dev "$root/dev"
    errorcheck && return 1
    mount --rbind /dev/pts "$root/dev/pts"
    errorcheck && return 1
    mount --rbind /proc "$root/proc"
    errorcheck && return 1
    mount --rbind /sys  "$root/sys"
    errorcheck && return 1

    echo "saving system settings to install location"
    set_server_setting "password" "$admin_password" "$root"
    set_server_setting "backup-sync-enabled" "$SYNC_DATA" "$root"
    set_server_setting "backup-enabled" "$BACKUP_ENABLED" "$root"
    set_server_setting "fast-storage-enabled" "$FAST_STORAGE_ENABLED" "$root"
    set_server_setting "slow-storage-enabled" "$SLOW_STORAGE_ENABLED" "$root"
    set_server_setting "services-enabled" "$SERVICES_ENABLED" "$root"
    set_server_setting "fast-disks" "$fast_disks" "$root"
    set_server_setting "slow-disks" "$slow_disks" "$root"
    set_server_setting "boot-disks" "$boot_disks" "$root"
    set_server_setting "link-backup" "$LINK_BACKUP" "$root"

    echo "running patches in install location"
    server_update
    errorcheck && echoerr "error in server_update" && return 1

    echo "unmounting bind in install location"
    umount -l "$root/dev/pts"
    errorcheck && return 1
    umount -l "$root/dev"
    errorcheck && return 1
    umount -l "$root/proc"
    errorcheck && return 1
    umount -l "$root/sys"
    errorcheck && return 1

    echo "removing $ROOT_POOL to prep for first boot"
    umount -lAR "$root"
    errorcheck && echoerr "error unmounting root pool" && return 1
    zpool export $ROOT_POOL
    errorcheck && echoerr "error exporting root pool" && return 1

    return 0
}

server_update() {
    [ "x$root" == "x" ] && local chroot_eval=

    echo "getting latest server code from git to $root$SERVER_INSTALL"
    #get latest server code
    [ ! -d "$root$SERVER_INSTALL" ] && git clone "$SERVER_GIT_LOCATION" "$root$SERVER_INSTALL"
    pushd "$root$SERVER_INSTALL"
    git remote update
    local local_rev=$(git rev-parse master)
    local server_rev=$(git rev-parse origin/master)
    [ $local_rev != $server_rev ] && git reset --hard origin/master
    popd

    echo "marking bin/patches executable"
    chmod +x "$root$SERVER_INSTALL/bin/"*
    chmod +x "$root$SERVER_INSTALL/patches/"*

    echo "kicking off patches"
    for patch in $(ls "$root$SERVER_INSTALL/patches")
    do
        echo "Starting patch: $patch"
        execute_patch "$patch" "$chroot_eval" "$root"
    done

    echo "waiting for patches to complete"
    for patch in $(ls "$root/var/run/server/patches")
    do
        wait_for_patch "$patch" "$(get_version "$patch" "$root")" "$root"
    done

    echo "running binary updates (apt)"
    #binary updates
    eval "$chroot_eval apt-get update -qq"
    errorcheck && echoerr "error during apt-get update" && return 1
    eval "$chroot_eval apt-get upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get upgrade" && return 1
    eval "$chroot_eval apt-get dist-upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get dist-upgrade" && return 1

    echo "server updates complete"
    return 0
}

wait_for_patch() {
    echo "waiting for patch: $1"
    local pid=$(get_patch_pid "$1")
    tail --pid=$pid -f "$3/var/log/server/patches/$1.log"
    while kill -0 $ppid >/dev/nul 2>&1
    do
        sleep 0.5s
    done
    clear_patch_pid "$1" "$3"
    check_version "$2" "$1" && \
        errorcheck && echoerr "patch failure: check log for $1 patch" \
        return 1
    echo "patch complete: $1"
    return 0
}

# 1=patch
# 2=chroot_eval (optional)
# 3=root (optional)
execute_patch() {
    local ppid=$(get_patch_pid "$1")
    if [ "x$ppid" == "x" ]
    then
        local chroot_eval=$2
        if [ "x$3" == "x" ]
        then
            local chroot_eval=
            echo "running ${1##*/} patch"
        else
            echo "running ${1##*/} patch in chroot '$3'"
        fi
        [ ! -d "$3/var/log/server/patches" ] && mkdir -p "$3/var/log/server/patches"
        eval "$chroot_eval \"$SERVER_INSTALL/patches/${1##*/}\" >\"$3/var/log/server/patches/${1##*/}.log\" 2>&1 &" >/dev/null 2>&1 && \
            set_patch_pid "${1##*/}" "$!" "$3"
    else
        echo "$1 patch already running - skipping"
    fi
    return 0
}

#checks version of patch files
#   returns 0 if the patch should run
#   meaning either the version is unknown greater than the last run
check_version() {
    [ -f "/etc/server/patches/$2" ] && local local_version=$(cat "/etc/server/patches/$2")
    [ "x$local_version" == "x" ] && return 1
    vers_test "$1" "-gt" "$local_version" && return 1 || return 0
}

set_version() {
    [ ! -d "/etc/server/patches" ] && mkdir -p "/etc/server/patches"
    echo $1 > "/etc/server/patches/$2"
    return 0
}

get_version() {
    [ -f "$2/etc/server/patches/$1" ] && echo $(cat "$2/etc/server/patches/$1") && return 0
    echo "0" && return 0
}

# 1=setting name
# 2=setting value
# 3=alt root (optional)
set_server_setting() {
    [ ! -d "$3/etc/server/settings" ] && mkdir -p "$3/etc/server/settings"
    echo "$2" > "$3/etc/server/settings/$1"
    chmod 600 "$3/etc/server/settings/$1"
    return 0
}

get_server_setting() {
    [ -f "$2/etc/server/settings/$1" ] && echo "$(cat $2/etc/server/settings/$1)" && return 0
    echoerr "no server setting for $1." && return 1
}

#checks to make sure a required patch has been run
#   1=patch name
#   2=minimum version of patch
patch_requires() {
    ! check_version "$2" "$1" || return 0
    echo "required patch $1 does not meet version $2"
    local ppid=$(get_patch_pid "$1")
    if [ "x$ppid" == "x" ]
    then
        echo "required patch $1 is not currently running"
        execute_patch $1
    fi
    wait_for_patch "$patch" $(get_version "$patch")
    ! check_version "$2" "$1" && echo "required patch $1 failed" && return 1 || return 0
}

# 1=patch
# 2=root (optional)
get_patch_pid() {
    [ -f "$2/var/run/server/patches/$1" ] && \
        echo $(cat "$2/var/run/server/patches/$1") && \
        return 0 || return 1
}

# 1=patch
# 2=value
# 3=root (optional)
set_patch_pid() {
    [ ! -d "$3/var/run/server/patches" ] && mkdir -p "$3/var/run/server/patches"
    echo "$2" > "$3/var/run/server/patches/$1"
    return 0
}

# 1=patch
# 2=root (optional)
clear_patch_pid() {
    [ -f "$2/var/run/server/patches/$1" ] && rm "$2/var/run/server/patches/$1" && return 0
    echoerr "no pid for $1 patch." && return 1
}

vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

vers_test() {
    vercomp $1 $3
    case $? in
        0) op='-eq';;
        1) op='-gt';;
        2) op='-lt';;
    esac
    if [[ $op != $2 ]]
    then
        return 1
    else
        return 0
    fi
}

#requires variables:
#   boot_disks
#       must be set to dev disk ex: "/dev/sda"
zfs_boot_setup() {
    local boot_disk_list=
    echo "clearing all boot disks"
    for boot_disk in $boot_disks
    do
        echo "clearing boot disk $boot_disk"
        clear_disk $boot_disk
        echo "partitioning boot disk $boot_disk"
        sleep 1s
        parted -s $boot_disk "mktable gpt"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 1mb 513mb"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 513mb -1"
        errorcheck && return 1
        parted -s $boot_disk "name 1 efi"
        errorcheck && return 1
        parted -s $boot_disk "set 1 boot on"
        errorcheck && return 1
        parted -s $boot_disk "name 2 system"
        errorcheck && return 1
        parted -s $boot_disk "set 2 bios_grub on"
        errorcheck && return 1
        sleep 1s
        local boot_disk_list="${boot_disk_list:-} $(get_disk_link ${boot_disk}2)"
    done
    echo "creating zfs boot pool"
    sleep 1s

    raid_type="mirror"
    [ $(howmany $boot_disk_list) -eq 1 ] && raid_type=""

    eval "zpool create -f \
        -o ashift=12 \
        -O atime=off \
        -O compression=lz4 \
        -O canmount=off \
        -m none \
        -R \"$root\" \
        $ROOT_POOL $raid_type $boot_disk_list"
    errorcheck && echoerr "error creating root pool" && return 1
    echo "setting up boot datasets"
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT/$SERVER_DIST
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=noauto -o mountpoint="/" $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error creating root pool dataset" && return 1

    zfs mount $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error mounting root pool" && return 1

    echo "boot disk setup complete"
    return 0
}

kill_children() {
    for child in $(ps -o pid,ppid -ax | awk "{ if ( \$2 == $1 ) { print \$1 }}")
    do
        kill_children "$child"
    done
    kill -0 $1 >/dev/null 2>&1 && kill $1
    return 0
}

echoerr() {
    cat <<< "$@" 1>&2
    return 0
}

errorcheck() {
    [ $? -ne 0 ] && return 0
    return 1
}

#count number of arguments
howmany() {
    case $- in
        *f* )
            set -- $1
        ;;
        * )
            set -f
            set -- $1
            set +f
        ;;
    esac
    echo $#
}

#gets a single /dev/disk/by-
#link based on the dev provided
#
#parameters:
#   1 - base dev ex: "/dev/sda"
#   2 - (optional) link type ex: "uuid"
#       this is anything under /dev/disk/by-
#       that would show up under DEVLINKS in udevadm
get_disk_link() {
    local filter="by-"${2:-"id"}
    udevadm info -q all $1 | grep DEVLINKS | sed 's/ /\n/g' | grep /dev/ | sed 's/DEVLINKS=//' | grep $filter | sort | head -n1
    errorcheck && return 1
    return 0
}

#removes all mounts/swaps/zpools from disk. anything that would prevent repartitioning.
#
#variables
#   1=dev disk ex: "/dev/sda"
clear_disk() {
    local disk=$1
    for swap in $(cat /proc/swaps | awk -v d=$disk '$1 ~ d {print $1}'); do swapoff $swap; done
    for mountpoint in $(mount | awk -v d=$disk '$1 ~ d {print $1}' | sort | uniq); do umount -lAR $mountpoint; done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $(get_disk_link $disk))" ] && zpool destroy $pool
    done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $disk)" ] && zpool destroy $pool;
    done
    which mdadm >/dev/null && mdadm --zero-superblock --force $disk
    sgdisk --zap $disk >/dev/null
    return 0
}

#filters quotes out of whatever is passed in
#useful for whiptail values with quotes in them
filter_quotes() {
    echo "$1" | sed 's/"//g'
}

#this is used to pass to whiptail to print available disks
#   note: disk with root "/" mounted is filtered automatically (if it is a disk)
#optional variables:
#   anything passed will act as a filter for output
#   ex: whiptail_disks /dev/sda /dev/sdb
#   this will print all available disks EXCEPT sda and adb.
whiptail_disks() {
    local whiptail_filter=$@
    local whiptail_output=$(lsblk -npr -o KNAME,MODEL,SIZE,TYPE,RO | \
    awk '$5 == 0 && $4 == "disk" {print $1 FS "\42"$2" ("$3")\42 OFF"}' | sed 's/\\x20/ /g')
    for f in $whiptail_filter; do
        local whiptail_output=$(echo "$whiptail_output" | grep -v $f)
    done
    local root_mount_name=$(mount | awk '/\ \/\ / {print $1}')
    echo "$(echo "$whiptail_output" | grep -v ${root_mount_name##/dev/})"
}
