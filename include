#!/usr/bin/env bash

#main entry point for install
clean_install(){
    echo "starting zfs boot setup"
    zfs_boot_setup
    errorcheck && echoerr "error setting up boot disks." && return 1

    echo "starting debootstrap"
    debootstrap --components $SERVER_DIST_COMPONENTS \
        --include $SERVER_DIST_PACKAGES \
        $SERVER_DIST_RELEASE "$root" $SERVER_DIST_URL
    errorcheck && echoerr "error in debootstrap" && return 1

    echo "bind mounting install location"
    mount --rbind /dev "$root/dev"
    errorcheck && return 1
    mount --rbind /dev/pts "$root/dev/pts"
    errorcheck && return 1
    mount --rbind /proc "$root/proc"
    errorcheck && return 1
    mount --rbind /sys  "$root/sys"
    errorcheck && return 1

    echo "saving system settings to install location"
    set_server_setting "password" "$admin_password" "$root"
    set_server_setting "backup-sync-enabled" "$SYNC_DATA" "$root"
    set_server_setting "backup-enabled" "$BACKUP_ENABLED" "$root"
    set_server_setting "fast-storage-enabled" "$FAST_STORAGE_ENABLED" "$root"
    set_server_setting "slow-storage-enabled" "$SLOW_STORAGE_ENABLED" "$root"
    set_server_setting "services-enabled" "$SERVICES_ENABLED" "$root"
    set_server_setting "fast-disks" "$fast_disks" "$root"
    set_server_setting "slow-disks" "$slow_disks" "$root"
    set_server_setting "boot-disks" "$boot_disks" "$root"
    set_server_setting "link-backup" "$LINK_BACKUP" "$root"

    echo "running patches in install location"
    server_update
    errorcheck && echoerr "error in server_update" && return 1

    echo "unmounting bind in install location"
    umount -l "$root/dev/pts"
    errorcheck && return 1
    umount -l "$root/dev"
    errorcheck && return 1
    umount -l "$root/proc"
    errorcheck && return 1
    umount -l "$root/sys"
    errorcheck && return 1

    echo "removing $ROOT_POOL to prep for first boot"
    umount -lAR "$root"
    errorcheck && echoerr "error unmounting root pool" && return 1
    zpool export $ROOT_POOL
    errorcheck && echoerr "error exporting root pool" && return 1

    return 0
}

server_update() {
    echo "getting latest server code from git to $root$SERVER_INSTALL"
    #get latest server code
    if [ ! -d "$root$SERVER_INSTALL" ]
    then
        git clone "$SERVER_GIT_LOCATION" "$root$SERVER_INSTALL"
        errorcheck && echoerr "failed to clone from git" && return 1
    fi
    pushd "$root$SERVER_INSTALL" >/dev/null
    git rev-parse --git-dir > /dev/null 2>&1
    errorcheck && popd >/dev/null && echoerr "directory not a git repo" && return 1
    git remote update >/dev/null
    errorcheck && popd >/dev/null && echoerr "failed to update git repo" && return 1
    local local_rev=$(git rev-parse master)
    local server_rev=$(git rev-parse origin/master)
    if [ $local_rev != $server_rev ]
    then
        git reset --hard origin/master >dev/null
        errorcheck && popd >/dev/null && echoerr "failed to reset git" && return 1
    fi
    popd >/dev/null

    echo "marking bin/patches executable"
    chmod +x "$root$SERVER_INSTALL/bin/"*
    chmod +x "$root$SERVER_INSTALL/patches/"*

    echo "kicking off patches"
    for patch in $(ls "$root$SERVER_INSTALL/patches")
    do
        execute_patch "$patch"
    done

    echo "waiting for patches to complete"
    for patch in $(ls "$root$SERVER_INSTALL/patches")
    do
        wait_for_patch "$patch"
    done

    echo "running binary updates (apt)"
    #binary updates
    eval "$chroot_eval apt-get update -qq"
    errorcheck && echoerr "error during apt-get update" && return 1
    eval "$chroot_eval apt-get upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get upgrade" && return 1
    eval "$chroot_eval apt-get dist-upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get dist-upgrade" && return 1

    echo "server updates complete"
    return 0
}

wait_for_patch() {
    local patch=${1##*/}
    check_waiting "$patch" && return 0
    set_waiting "$patch"
    local pid=$(get_patch_pid "$patch")
    echo "waiting for patch $patch on pid $pid"
    tail --pid=$pid -f "/var/log/server/patches/$patch.log"
    while kill -0 $ppid >/dev/nul 2>&1
    do
        sleep 0.5s
    done
    clear_patch_pid "$patch"
    clear_waiting "$patch"
    get_status "$patch"
    errorcheck && \
        echoerr "patch failure: check log for $patch patch" && \
        return 1
    echo "patch complete: $patch"
    return 0
}

set_waiting() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ ! -d "$root/var/run/server/waiting" ] && mkdir -p "$root/var/run/server/waiting"
    touch "$root/var/run/server/waiting/$patch"
    return 0
}

check_waiting() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ -f "$root/var/run/server/waiting/$patch" ] && return 0 || return 1
}

clear_waiting() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ -f "$root/var/run/server/waiting/$patch" ] && rm "$root/var/run/server/waiting/$patch"
    return 0
}

get_log_name() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ ! -d "$root/var/log/server/patches" ] && mkdir -p "$root/var/log/server/patches"
    [ ! -f "$root/var/log/server/patches/$patch.log" ] && \
        echo "$root/var/log/server/patches/$patch.log" && return 0
    local ln=1
    while [ -f "$root/var/log/server/patches/$patch.$ln.log" ]
    do
        ln=$((ln+1))
    done
    mv "$root/var/log/server/patches/$patch.log" "$root/var/log/server/patches/$patch.$ln.log"
    echo "$root/var/log/server/patches/$patch.log"
    return 0
}

execute_patch() {
    local patch=${1##*/}
    local ppid=$(get_patch_pid "$patch")
    [ "x$ppid" != "x" ] && \
        echo "patch $patch already running on pid $ppid - skipping" && \
        return 0
    async_patch "$patch" >/dev/null 2>&1
    echo "started $patch patch on pid $(get_patch_pid "$patch")"
    return 0
}

patch_failure() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ ! -d "$root/etc/server/patches" ] && mkdir -p "$root/etc/server/patches"
    echo "$2" > "$root/etc/server/patches/$patch.failure"
}

get_status() {
    [ ! -d $root ] && local root=
    [ ! -f "$root/etc/server/patches/$patch.failure" ] && return 0
    return $(cat "$root/etc/server/patches/$patch.failure")
}

async_patch() {
    local patch=${1##*/}
    [ "x$root" == "x" ] && local chroot_eval=
    {
        eval "$chroot_eval \"$SERVER_INSTALL/patches/$patch\"" >"$(get_log_name "$patch")" 2>&1
        errorcheck && patch_failure "$patch" "$status"
        return 0
    } & >/dev/null 2>&1
    set_patch_pid "$patch" "$!"
}

patch_requires() {
    local patch=${1##*/}
    local version=$2
    local ppid=$(get_patch_pid "$patch")
    if [ "x$ppid" != "x" ]
    then
        echo "required patch $patch current running on pid $ppid - waiting"
    else
        get_status "$patch"
        errorcheck && echoerr "required patch $patch failed" && return 1
        check_version "$version" "$patch" && echo "required patch $patch already on latest version." && return 0
        echo "required patch $patch does not meet version $version - executing"
        execute_patch "$patch"
    fi
    wait_for_patch "$patch"
    errorcheck && echo "required patch $patch failed" && return 1 || return 0
}

get_patch_pid() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ -f "$root/var/run/server/patches/$patch" ] && \
        echo $(cat "$root/var/run/server/patches/$patch") && \
        return 0 || return 1
}

set_patch_pid() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ ! -d "$root/var/run/server/patches" ] && mkdir -p "$root/var/run/server/patches"
    echo "$2" > "/var/run/server/patches/$patch"
    return 0
}

clear_patch_pid() {
    local patch=${1##*/}
    [ ! -d $root ] && local root=
    [ -f "$root/var/run/server/patches/$patch" ] && rm "$root/var/run/server/patches/$patch" && return 0
    echoerr "no pid for $patch patch." && return 1
}

#checks version of patch files
#   returns 1 if the patch should run
#   meaning either the version is unknown or less than or equal to the last run
check_version() {
    local patch=${2##*/}
    [ ! -d $root ] && local root=
    [ -f "$root/etc/server/patches/$patch" ] && \
        local local_version=$(cat "$root/etc/server/patches/$patch")
    [ "x$local_version" == "x" ] && return 1
    vers_test "$1" "-gt" "$local_version" && return 1 || return 0
}

set_version() {
    local patch=${2##*/}
    [ ! -d $root ] && local root=
    [ ! -d "$root/etc/server/patches" ] && mkdir -p "$root/etc/server/patches"
    echo "$1" > "/etc/server/patches/$patch"
    return 0
}

set_server_setting() {
    local setting=$1
    [ ! -d $root ] && local root=
    [ ! -d "$root/etc/server/settings" ] && mkdir -p "$root/etc/server/settings"
    echo "$2" > "$root/etc/server/settings/$setting"
    chmod 600 "$root/etc/server/settings/$setting"
    return 0
}

get_server_setting() {
    local setting=$1
    [ ! -d $root ] && local root=
    [ -f "/etc/server/settings/$setting" ] && echo "$(cat /etc/server/settings/$setting)" && return 0
    echoerr "no server setting named $setting" && return 1
}

vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

vers_test() {
    vercomp $1 $3
    case $? in
        0) op='-eq';;
        1) op='-gt';;
        2) op='-lt';;
    esac
    if [[ $op != $2 ]]
    then
        return 1
    else
        return 0
    fi
}

#requires variables:
#   boot_disks
#       must be set to dev disk ex: "/dev/sda"
zfs_boot_setup() {
    local boot_disk_list=
    echo "clearing all boot disks"
    for boot_disk in $boot_disks
    do
        echo "clearing boot disk $boot_disk"
        clear_disk $boot_disk
        echo "partitioning boot disk $boot_disk"
        sleep 1s
        parted -s $boot_disk "mktable gpt"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 1mb 513mb"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 513mb -1"
        errorcheck && return 1
        parted -s $boot_disk "name 1 efi"
        errorcheck && return 1
        parted -s $boot_disk "set 1 boot on"
        errorcheck && return 1
        parted -s $boot_disk "name 2 system"
        errorcheck && return 1
        parted -s $boot_disk "set 2 bios_grub on"
        errorcheck && return 1
        sleep 1s
        local boot_disk_list="${boot_disk_list:-} $(get_disk_link ${boot_disk}2)"
    done
    echo "creating zfs boot pool"
    sleep 1s

    raid_type="mirror"
    [ $(howmany $boot_disk_list) -eq 1 ] && raid_type=""

    eval "zpool create -f \
        -o ashift=12 \
        -O atime=off \
        -O compression=lz4 \
        -O canmount=off \
        -m none \
        -R \"$root\" \
        $ROOT_POOL $raid_type $boot_disk_list"
    errorcheck && echoerr "error creating root pool" && return 1
    echo "setting up boot datasets"
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT/$SERVER_DIST
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=noauto -o mountpoint="/" $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error creating root pool dataset" && return 1

    zfs mount $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error mounting root pool" && return 1

    echo "boot disk setup complete"
    return 0
}

kill_children() {
    for child in $(ps -o pid,ppid -ax | awk "{ if ( \$2 == $1 ) { print \$1 }}")
    do
        kill_children "$child"
    done
    kill -0 $1 >/dev/null 2>&1 && kill $1
    return 0
}

echoerr() {
    cat <<< "$@" 1>&2
    return 0
}

errorcheck() {
    [ $? -ne 0 ] && return 0
    return 1
}

#count number of arguments
howmany() {
    case $- in
        *f* )
            set -- $1
        ;;
        * )
            set -f
            set -- $1
            set +f
        ;;
    esac
    echo $#
}

#gets a single /dev/disk/by-
#link based on the dev provided
#
#parameters:
#   1 - base dev ex: "/dev/sda"
#   2 - (optional) link type ex: "uuid"
#       this is anything under /dev/disk/by-
#       that would show up under DEVLINKS in udevadm
get_disk_link() {
    local filter="by-"${2:-"id"}
    udevadm info -q all $1 | grep DEVLINKS | sed 's/ /\n/g' | grep /dev/ | sed 's/DEVLINKS=//' | grep $filter | sort | head -n1
    errorcheck && return 1
    return 0
}

#removes all mounts/swaps/zpools from disk. anything that would prevent repartitioning.
#
#variables
#   1=dev disk ex: "/dev/sda"
clear_disk() {
    local disk=$1
    for swap in $(cat /proc/swaps | awk -v d=$disk '$1 ~ d {print $1}'); do swapoff $swap; done
    for mountpoint in $(mount | awk -v d=$disk '$1 ~ d {print $1}' | sort | uniq); do umount -lAR $mountpoint; done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $(get_disk_link $disk))" ] && zpool destroy $pool
    done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $disk)" ] && zpool destroy $pool;
    done
    which mdadm >/dev/null && mdadm --zero-superblock --force $disk
    sgdisk --zap $disk >/dev/null
    return 0
}

#filters quotes out of whatever is passed in
#useful for whiptail values with quotes in them
filter_quotes() {
    echo "$1" | sed 's/"//g'
}

#this is used to pass to whiptail to print available disks
#   note: disk with root "/" mounted is filtered automatically (if it is a disk)
#optional variables:
#   anything passed will act as a filter for output
#   ex: whiptail_disks /dev/sda /dev/sdb
#   this will print all available disks EXCEPT sda and adb.
whiptail_disks() {
    local whiptail_filter=$@
    local whiptail_output=$(lsblk -npr -o KNAME,MODEL,SIZE,TYPE,RO | \
    awk '$5 == 0 && $4 == "disk" {print $1 FS "\42"$2" ("$3")\42 OFF"}' | sed 's/\\x20/ /g')
    for f in $whiptail_filter; do
        local whiptail_output=$(echo "$whiptail_output" | grep -v $f)
    done
    local root_mount_name=$(mount | awk '/\ \/\ / {print $1}')
    echo "$(echo "$whiptail_output" | grep -v ${root_mount_name##/dev/})"
}
