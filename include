#!/usr/bin/env bash

#main entry point for install
clean_install(){
    zfs_boot_setup
    errorcheck && echoerr "error setting up boot disks." && return 1

    debootstrap --components $SERVER_DIST_COMPONENTS \
        --include $SERVER_DIST_PACKAGES \
        $SERVER_DIST_RELEASE "$root" $SERVER_DIST_URL
    errorcheck && echoerr "error in debootstrap" && return 1

    mount --rbind /dev "$root/dev"
    errorcheck && return 1
    mount --rbind /dev/pts "$root/dev/pts"
    errorcheck && return 1
    mount --rbind /proc "$root/proc"
    errorcheck && return 1
    mount --rbind /sys  "$root/sys"
    errorcheck && return 1

    set_server_setting "password" $admin_password $root
    set_server_setting "backup-sync-enabled" $SYNC_DATA $root
    set_server_setting "backup-enabled" $BACKUP_ENABLED $root
    set_server_setting "fast-storage-enabled" $FAST_STORAGE_ENABLED $root
    set_server_setting "slow-storage-enabled" $SLOW_STORAGE_ENABLED $root
    set_server_setting "services-enabled" $SERVICES_ENABLED $root
    set_server_setting "fast-disks" $fast_disks $root
    set_server_setting "slow-disks" $slow_disks $root
    set_server_setting "link-backup" $LINK_BACKUP $root

    server_update
    errorcheck && echoerr "error in server_update" && return 1

    umount -l "$root/dev/pts"
    errorcheck && return 1
    umount -l "$root/dev"
    errorcheck && return 1
    umount -l "$root/proc"
    errorcheck && return 1
    umount -l "$root/sys"
    errorcheck && return 1

    umount -lAR "$root"
    errorcheck && echoerr "error unmounting root pool" && return 1
    zpool export $ROOT_POOL
    errorcheck && echoerr "error exporting root pool" && return 1

    return 0
}

server_update() {
    [ x$root = x ] && local chroot_eval=

    #get latest server code
    [ ! -d "$root$SERVER_INSTALL/server" ] && git clone $SERVER_GIT_LOCALTION "$root$SERVER_INSTALL/server"
    pushd "$root$SERVER_INSTALL/server"
    git remote update
    local_rev=$(git rev-parse master)
    server_rev=$(git rev-parse origin/master)
    [ $local_rev != $server_rev ] && git reset --hard origin/master
    popd

    chmod +x "$root$SERVER_INSTALL/server/bin/"*
    chmod +x "$root$SERVER_INSTALL/server/patches/"*

    for patch in $(ls "$root$SERVER_INSTALL/server/patches")
    do
        echo "Starting patch: $patch"
        execute_patch $patch $chroot_eval
        set_patch_pid $patch $! $root
    done

    for patch in $(ls "$root$SERVER_INSTALL/server/patches")
    do
        echo "waiting for watch: $patch"
        wait $(get_patch_pid $patch $! $root) && clear_patch_pid
        errorcheck && echoerr "error running $patch patch" && cancel_patches
        echo "patch complete: $patch"
    done

    #binary updates
    eval "$chroot_eval apt-get update -qq"
    errorcheck && echoerr "error during apt-get update" && return 1
    eval "$chroot_eval apt-get upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get upgrade" && return 1
    eval "$chroot_eval apt-get dist-upgrade -qq --no-install-recommends"
    errorcheck && echoerr "error during apt-get dist-upgrade" && return 1

    return 0
}

execute_patch() {
    chroot_eval=$2
    patch=$1
    eval "$chroot_eval $(cat $SERVER_INSTALL/environment) $SERVER_INSTALL/server/patches/$patch > /var/server/logs/patches/$patch.log" &
}

#checks version of patch files
#   returns 0 if the patch should run
#   meaning either the version is unknown greater than the last run
check_version() {
    script_version=$1
    script_name=$2
    [ -f "$SERVER_INSTALL/server/$script_name" ] && local_version=$(cat "$SERVER_INSTALL/patches/$script_name")
    [ x$local_version = x ] && return 1
    vers_test $script_version -gt $local_version && return 1 || return 0
}

set_version() {
    [ ! -d "$SERVER_INSTALL/patches" ] && mkdir -p "$SERVER_INSTALL/patches"
    echo $1 > "$SERVER_INSTALL/patches/$2"
    return 0
}

set_server_setting() {
    [ ! -d "$3$SERVER_INSTALL/server-settings" ] && mkdir -p "$3$SERVER_INSTALL/server-settings"
    echo $2 > "$3$SERVER_INSTALL/server-settings/$1"
    chmod 600 "$3$SERVER_INSTALL/server-settings/$1"
    return 0
}

get_server_setting() {
    [ -f "$2$SERVER_INSTALL/server-settings/$1" ] && echo "$(cat $2$SERVER_INSTALL/server-settings/$1)" && return 0
    echoerr "no server setting for $1." && return 1
}

#checks to make sure a required patch has been run
#   1=patch name
#   2=minimum version of patch
patch_requires() {
    if check_version $2 $1
    then
        get_patch_pid $1
        execute_patch $1
        errorcheck && echoerr "required patch $1 failed" && return 1
    fi
    return 0
}

get_patch_pid() {
    [ -f "$3/var/run/server/patches/$1" ] && echo $(cat "$3/var/run/server/patches/$1") && return 0
    echoerr "no pid for $1 patch." && return 1
}

set_patch_pid() {
    [ ! -d "$3/var/run/server/patches" ] && mkdir -p "$3/var/run/server/patches"
    echo "$2" > "$3/var/run/server/patches/$1"
    return 0
}

clear_patch_pid() {
    [ -f "$3/var/run/server/patches/$1" ] && rm "$3/var/run/server/patches/$1" && return 0
    echoerr "no pid for $1 patch." && return 1
}

check_pid() {
    ppid=$(get_patch_pid $1 $3)
    ppid=${ppid:-$2}

    if [ $ppid -ne $2 ]
    then
        echo "$1 patch already running on pid $ppid - exiting"
        return 0
    fi

    return 1
}

vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

vers_test() {
    vercomp $1 $3
    case $? in
        0) op='-eq';;
        1) op='-gt';;
        2) op='-lt';;
    esac
    if [[ $op != $2 ]]
    then
        return 1
    else
        return 0
    fi
}

#requires variables:
#   boot_disks
#       must be set to dev disk ex: "/dev/sda"
zfs_boot_setup() {
    boot_disk_list=
    space=
    echo "clearing all boot disks"
    for boot_disk in $boot_disks
    do
        echo "clearing boot disk $boot_disk"
        clear_disk $boot_disk
        echo "partitioning boot disk $boot_disk"
        sleep 1s
        parted -s $boot_disk "mktable gpt"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 1mb 513mb"
        errorcheck && return 1
        parted -s $boot_disk "mkpart primary 513mb -1"
        errorcheck && return 1
        parted -s $boot_disk "name 1 efi"
        errorcheck && return 1
        parted -s $boot_disk "set 1 boot on"
        errorcheck && return 1
        parted -s $boot_disk "name 2 system"
        errorcheck && return 1
        parted -s $boot_disk "set 2 bios_grub on"
        errorcheck && return 1
        sleep 1s
        boot_disk_list="${boot_disk_list:-}${space:-}$(get_disk_link ${boot_disk}2)"
        space=" "
    done
    echo "creating zfs boot pool"
    sleep 1s

    raid_type="mirror"
    [ $(howmany $boot_disk_list) -eq 1 ] && raid_type=""

    eval "zpool create -f \
        -o ashift=12 \
        -O atime=off \
        -O compression=lz4 \
        -O canmount=off \
        -m none \
        -R "$root" \
        $ROOT_POOL $raid_type $boot_disk_list"
    errorcheck && echoerr "error creating root pool" && return 1
    echo "setting up boot datasets"
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=off -o mountpoint=none $ROOT_POOL/ROOT/$SERVER_DIST
    errorcheck && echoerr "error creating root pool dataset" && return 1
    zfs create -o canmount=noauto -o mountpoint="/" $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error creating root pool dataset" && return 1

    zfs mount $ROOT_POOL/ROOT/$SERVER_DIST/$SERVER_DIST_RELEASE
    errorcheck && echoerr "error mounting root pool" && return 1

    echo "boot disk setup complete"
    return 0
}

kill_children() {
    for child in $(ps -o pid,ppid -ax | awk "{ if ( \$2 == $1 ) { print \$1 }}")
    do
        kill_children $child
    done
    kill -0 $1 >/dev/null 2>&1 && kill $1
    return 0
}

echoerr() {
    cat <<< "$@" 1>&2
    return 0
}

errorcheck() {
    [ $? -ne 0 ] && return 0
    return 1
}

#count number of arguments
howmany() {
    case $- in
        *f* )
            set -- $1
        ;;
        * )
            set -f
            set -- $1
            set +f
        ;;
    esac
    echo $#
}

get_parent_disk() {
    echo "/dev/$(lsblk -n -o PKNAME $1)"
}

#returns /dev/ada type links to disks that are part of provided pool
get_pool_disks() {
    pool=$1
    disk_links=$(zpool list -v -P $pool | grep /dev/disk | awk '{print $1}')
    devlist=
    for disk in $disk_links
    do
        devlist="$devlist $(get_parent_disk $(udevadm info -q all $disk | grep DEVNAME | sed 's/ /\n/g' | grep /dev/ | sed 's/DEVNAME=//'))"
    done
    echo $devlist
}

#gets a single /dev/disk/by-
#link based on the dev provided
#
#parameters:
#   1 - base dev ex: "/dev/sda"
#   2 - (optional) link type ex: "uuid"
#       this is anything under /dev/disk/by-
#       that would show up under DEVLINKS in udevadm
get_disk_link() {
    filter="by-"${2:-"id"}
    udevadm info -q all $1 | grep DEVLINKS | sed 's/ /\n/g' | grep /dev/ | sed 's/DEVLINKS=//' | grep $filter | sort | head -n1
    errorcheck && return 1
    return 0
}

#removes all mounts/swaps/zpools from disk. anything that would prevent repartitioning.
#
#variables
#   1=dev disk ex: "/dev/sda"
clear_disk() {
    local disk=$1
    for swap in $(cat /proc/swaps | awk -v d=$disk '$1 ~ d {print $1}'); do swapoff $swap; done
    for mountpoint in $(mount | awk -v d=$disk '$1 ~ d {print $1}' | sort | uniq); do umount -lAR $mountpoint; done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $(get_disk_link $disk))" ] && zpool destroy $pool
    done
    for pool in $(zpool list -H | awk '{print $1}'); do
        [ -n "$(zpool status -P $pool | grep $disk)" ] && zpool destroy $pool;
    done
    which mdadm >/dev/null && mdadm --zero-superblock --force $disk
    sgdisk --zap $disk >/dev/null
    return 0
}

#filters quotes out of whatever is passed in
#useful for whiptail values with quotes in them
filter_quotes() {
    echo "$1" | sed 's/"//g'
}

#ex:
#input: /dev/sda
#output: sda
#removes everything to the left of and including the last "/"
trim_disk_link() {
    echo ${1##*/}
}

#this is used to pass to whiptail to print available disks
#   note: disk with root "/" mounted is filtered automatically (if it is a disk)
#optional variables:
#   anything passed will act as a filter for output
#   ex: whiptail_disks /dev/sda /dev/sdb
#   this will print all available disks EXCEPT sda and adb.
whiptail_disks() {
    whiptail_filter=$@
    whiptail_output=$(lsblk -npr -o KNAME,MODEL,SIZE,TYPE,RO | \
    awk '$5 == 0 && $4 == "disk" {print $1 FS "\42"$2" ("$3")\42 OFF"}' | sed 's/\\x20/ /g')
    for f in $whiptail_filter; do
        whiptail_output=$(echo "$whiptail_output" | grep -v $f)
    done
    root_mount_name=$(mount | awk '/\ \/\ / {print $1}')
    echo "$(echo "$whiptail_output" | grep -v ${root_mount_name##/dev/})"
}
